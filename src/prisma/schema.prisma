datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id             String    @id
  email          String    @unique
  name           String?
  avatarUrl      String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  topics         Topic[]
  quizzes        Quiz[]
  answers        Answer[]
  progress       Progress[]
  attempts       QuizAttempt[]
  subscription   UserSubscription?
  usage          UserUsage?
  documents      Document[]
  chatSessions   ChatSession[]
  adminProfile   AdminUser?
}

model Topic {
  id          String    @id @default(uuid())
  name        String
  description String?
  createdAt   DateTime  @default(now())

  user        User      @relation(fields: [userId], references: [id])
  userId      String

  quizzes     Quiz[]
  progress    Progress[]
  suggestions Suggestion[]
}

model Quiz {
  id          String     @id @default(uuid())
  title       String
  type        QuizType
  difficulty  Difficulty
  createdAt   DateTime   @default(now())
  expiresAt   DateTime?
  timer       Int?       // in seconds
  status      QuizStatus @default(PENDING)
  count       Int
  topic       Topic?     @relation(fields: [topicId], references: [id], onDelete: SetNull)
  topicId     String?
  document    Document?  @relation(fields: [documentId], references: [id], onDelete: SetNull)
  documentId  String?

  user        User       @relation(fields: [userId], references: [id])
  userId      String

  questions   Question[]
  attempts    QuizAttempt[]
  
  @@index([documentId])
}

model Question {
  id          String        @id @default(uuid())
  text        String
  type        QuestionType
  options     Json?         // For MCQ (array of strings)
  correct     String?       // Correct answer
  createdAt   DateTime      @default(now())

  quiz        Quiz          @relation(fields: [quizId], references: [id])
  quizId      String

  explanation Explanation?
  answers     Answer[]
}

model Answer {
  id          String     @id @default(uuid())
  userAnswer  String
  isCorrect   Boolean
  createdAt   DateTime   @default(now())

  question    Question   @relation(fields: [questionId], references: [id])
  questionId  String

  user        User       @relation(fields: [userId], references: [id])
  userId      String

  attempt     QuizAttempt? @relation(fields: [attemptId], references: [id])
  attemptId   String?
}

model QuizAttempt {
  id            String        @id @default(uuid())
  status        AttemptStatus @default(IN_PROGRESS)
  score         Float?        // Percentage score (0-100), null until completed
  correctCount  Int?          // null until completed
  totalQuestions Int          // Total questions in the quiz
  elapsedTime   Int?          // Time elapsed so far in seconds (for paused attempts)
  timeSpent     Int?          // Final time spent in seconds (only set when completed)
  pausedAt      DateTime?     // When the attempt was paused
  completedAt   DateTime?     // When the attempt was completed (null if in progress/paused)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @default(now()) @updatedAt

  quiz          Quiz          @relation(fields: [quizId], references: [id])
  quizId        String

  user          User          @relation(fields: [userId], references: [id])
  userId        String

  answers       Answer[]
}

model Explanation {
  id           String    @id @default(uuid())
  content      String
  createdAt    DateTime  @default(now())

  question     Question  @relation(fields: [questionId], references: [id])
  questionId   String    @unique
}

model Progress {
  id           String    @id @default(uuid())
  score        Float     @default(0)
  total        Int       @default(0)
  streak       Int       @default(0)
  lastActive   DateTime  @default(now())

  topic        Topic     @relation(fields: [topicId], references: [id])
  topicId      String

  user         User      @relation(fields: [userId], references: [id])
  userId       String
}

model Suggestion {
  id           String    @id @default(uuid())
  suggestedTopic String
  reason        String?
  createdAt     DateTime  @default(now())

  topic         Topic     @relation(fields: [topicId], references: [id])
  topicId       String
}



enum QuizType {
  MULTIPLE_CHOICE
  TRUE_FALSE
  SHORT_ANSWER
}

enum QuestionType {
  MULTIPLE_CHOICE
  TRUE_FALSE
  SHORT_ANSWER
  FILL_IN_BLANK
}

enum Difficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum QuizStatus {
  PENDING
  ACTIVE
  COMPLETED
}

enum AttemptStatus {
  IN_PROGRESS
  PAUSED
  COMPLETED
}

model SubscriptionPlan {
  id              String   @id @default(uuid())
  name            String
  stripePriceId   String?  @unique
  stripeProductId String?
  isDefault       Boolean  @default(false)
  isActive        Boolean  @default(true)
  isCustom        Boolean  @default(false)
  // Limits
  maxTopics       Int      @default(5)
  maxQuizzes      Int      @default(10)
  maxDocuments    Int      @default(0)
  allowedModels   String[] // e.g., ["gpt-3.5-turbo", "gpt-4-turbo"]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  subscriptions   UserSubscription[]
}


model UserSubscription {
  id                String   @id @default(uuid())
  userId            String   @unique
  planId            String
  stripeCustomerId  String?  @unique
  stripeSubscriptionId String? @unique
  
  // Current effective limits (can be overridden by admin)
  maxTopics         Int
  maxQuizzes        Int
  maxDocuments      Int
  allowedModels     String[]
  
  // Subscription status
  status            SubscriptionStatus @default(ACTIVE)
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  cancelAtPeriodEnd  Boolean @default(false)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan              SubscriptionPlan @relation(fields: [planId], references: [id])
  
  @@index([userId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
}

model UserUsage {
  id            String   @id @default(uuid())
  userId        String   @unique
  
  topicsCount   Int      @default(0)
  quizzesCount  Int      @default(0)
  documentsCount Int     @default(0)
  
  lastResetAt   DateTime @default(now())
  
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

model AdminUser {
  id            String   @id @default(uuid())
  userId        String   @unique
  role          AdminRole @default(MODERATOR)
  permissions   String[]
  createdAt     DateTime @default(now())
  
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

model Document {
  id            String   @id @default(uuid())
  userId        String
  filename      String
  filePath      String
  fileSize      Int
  mimeType      String
  status        DocumentStatus @default(UPLOADING)
  vectorized    Boolean  @default(false)
  chunkCount    Int      @default(0)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  embeddings    DocumentEmbedding[]
  chatSessions  ChatSession[]
  quizzes       Quiz[]
  
  @@index([userId])
  @@index([status])
  @@index([vectorized])
}

model DocumentEmbedding {
  id            String   @id @default(uuid())
  documentId    String
  chunkIndex    Int
  chunkText     String   @db.Text
  embedding     Unsupported("vector(1536)") // OpenAI embedding dimension
  metadata      Json?    // Store additional metadata like page number, section, etc.
  
  createdAt     DateTime @default(now())
  
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@index([documentId])
  @@index([chunkIndex])
}

model ChatSession {
  id            String   @id @default(uuid())
  userId       String
  documentId   String?
  title        String?  // Auto-generated or user-provided
  model        String   @default("gpt-4-turbo") // AI model used
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  document     Document? @relation(fields: [documentId], references: [id], onDelete: SetNull)
  messages     ChatMessage[]
  
  @@index([userId])
  @@index([documentId])
}

model ChatMessage {
  id            String   @id @default(uuid())
  sessionId     String
  role          ChatRole
  content       String   @db.Text
  contextChunks Json?    // Store relevant document chunks used for RAG
  tokenCount    Int?     // Track token usage
  
  createdAt     DateTime @default(now())
  
  session       ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  @@index([sessionId])
  @@index([createdAt])
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  UNPAID
  TRIALING
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  MODERATOR
}

enum DocumentStatus {
  UPLOADING
  PROCESSING
  READY
  FAILED
}

enum ChatRole {
  USER
  ASSISTANT
  SYSTEM
}